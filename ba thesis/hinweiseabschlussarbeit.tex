%!TEX encoding = UTF-8 Unicode
% ================================================================================
\documentclass[
    fontsize=12pt,
    headings=small,
    parskip=half,           % Ersetzt manuelles Setzen von parskip/parindent.
    bibliography=totoc,
    numbers=noenddot,       % Entfernt den letzten Punkt der Kapitelnummern.
    open=any,               % Kapitel kann auf jeder Seite beginnen.
%   final                   % Entfernt alle todonotes und den Entwurfstempel.
    ]{scrreprt}
% ===================================Praeambel==================================
\include{stylesvs}
% ===================================Dokument===================================

\title{Entwicklung eines Visualisierungswerkzeuges zur Demons-
tration datenschutzfreundlicher Dokumentspeicherdienste}
\author{David Kirchhausen Monteiro}

\begin{document}

\begin{titlepage}% {{{
\includegraphics[width=6.8cm]{../pic/up-uhh-logo-u-2010-u-farbe-u-rgb.pdf}
\begin{center}\Large
	% Universität Hamburg \par
	% Fachbereich Informatik
	\vfill
	Bachelorarbeit
	\vfill
	\makeatletter
	{\Large\textsf{\textbf{\@title}}\par}
	\makeatother
	\vfill
	vorgelegt von
	\par\bigskip
	\makeatletter
	{\@author} \par
	\makeatother
	geb. am 24. Januar 1994 in Hildesheim \par
	Matrikelnummer 6530927 \par
	Studiengang Software-System-Entwicklung
	\vfill
	\makeatletter
	eingereicht am {\@date}
	\makeatother
	\vfill
	Betreuer: Maximilian Blochberger, M. Sc. \par
	Erstgutachter: Prof. Dr.-Ing. Hannes Federrath \par
	Zweitgutachter: Tilmann Stehle, M. Sc.
\end{center}
\ifoptionfinal{}{}
\end{titlepage}% }}}
\chapter*{Aufgabenstellung}

Im  Zuge  dieser  Bachelorarbeit  soll  ein  einfacher  Dokumentenspeicher  entwickelt  werden,
welcher möglichst viele Nutzerdaten erfasst und speichert. Die erfassten Daten sollen anschaulich
grafisch dargestellt werden können. Weiter sollen verschiedene Szenarien entwickelt werden,
welche aufzeigen wie eine mögliche Benutzung des Services mit und ohne der Verwendung
von datenschutzfreundlichen Methoden zum Anonymisieren von Daten aussieht. Anhand der
Szenarien soll eine grafische Auswertung Unterschiede zwischen anonymisierten Daten und
nicht anonymisierten Daten visuell sichtbar machen und die Unterschiede somit leicht zugänglich
sein.

\chapter*{Zusammenfassung}
\begin{enumerate}
\item Dokumentenspeicherdienste Vorteile (Problemstellung erläutern)
\item Mögliche Datenschutz unfreundliche Aspekte von gängigen Anbietern (Problemstellung erläutern)
\item Entwicklung des Dokumentenspeichers und der Visualisierung zur deutlich Veranschaulichung von Potentiellen Unterschieden zwischen der Verwendung von Datenschutz freundlichen Methoden zum Anonymisieren oder nicht. (Bearbeitung der Problemstellung)
\begin{enumerate}
\item Implementation des Dokumentenspeichers
\item Implementation der API zur Datenübergabe 
\item Implementation des Visualisierungswerkzeug
\item Darstellung der Szenarien zur Benutzung des Visualisierungswerkzeug
\end{enumerate}
\end{enumerate}

\tableofcontents

\chapter{Einleitung}

Dokumentenspeicherdienste sind nützliche Alltagsgegenstände, welche für private sowie kommerzielle Nutzer meist unverzichtbar sind. Sie bieten nicht nur den Speicherplatz für wichtige Dateien der Nutzer sondern stellen auch die Sicherheit der Dateien sicher und machen sie global jeder zeit verfügbar. Durch die große Datensammlung dieser Dienstleister machen sie sich nicht nur selbst zu lukrativen Zielen von gezielten Angriffen (Yahoo, UBER etc.), jedoch auch die Dienstleister selber können die Daten auswerten und meitere Meta-Daten über die Nutzer sammeln und weiter verwenden. Vor allem private Nutzer sind meist gar nicht über die Risiken und das Missbrauchspotenziale aufgeklärt, welche die Verwendung solcher Dienstleistungen mit sich bringen. Methoden zur Verschlüsselung oder des Anonymisieren von Daten sind Benutzern meist nicht bekannt, werden von den Dienstanbietern nicht angeboten oder sind schwer umzusetzen da es einen meist erheblichen Aufwand für die Benutzer bedeutet und Kompetenzen erfordert welche diese Benutzer nicht besitzen. Um genau die Risiken und Missbrauchspotenziale aufzuzeigen wird im Zuge dieser Arbeit ein Dokumentenspeicherdienst entwickelt, welcher prinzipiell alle Meta-Daten der Nutzer sammelt und diese in einer visuellen Darstellung zusammen fasst. Zur Implementation des Dokumentenspeichers wird dabei das Microsoft ASP.NET Core Framework verwendet. Das Framework wird benutzt um die Webbenutzeroberfläche sowie der Web-APIs des Dokumentenspeichers zu realisieren. Dazu wird das Javascript Framework Data-Driven Documents, i.d.R. d3.js genannt, zur Visualisierung der Daten verwendet. Der Dokumentenspeicher soll vor allem den Unterschied zwischen der Verwendung von Methoden zur Verschlüsselung oder des Anonymisieren von Daten visualisieren und verwaltet dazu zwei verschiedene Datensätze, wobei eine Datenmenge ohne, und eine Datenmenge mit der Verwendung von Methoden zur Verschlüsselung oder des Anonymisieren von Daten erzeugt wird. Der entstehende Unterschied der gesammelten Meta-Daten durch die verschiedenen Methoden führt dann zu einer Veränderung in der Visualisierung was dan den Effekt und Nutzen der Methoden deutlich sichtbar macht.  

\chapter{Grundlagen}

\section{Terminologie}
\begin{enumerate}
\item HTTP-Header
\begin{enumerate}
\item Teil des Hypertext Transfer Protocol (HTTP)
\item Headerblock und Headerfeld nach RFC 2616(https://tools.ietf.org/html/rfc2616)
\end{enumerate}
\item Geo lookup
\begin{enumerate}
\item eine Methodik zur Bestimmung des geografischen Standort einer IP-Adresse
\item keine eigenen Implementation der Standortbestimmung, sondern Verwendung eines öffentlich zugänglichen Service, aus Zeit und komplexitätsgründen
\item Patent US7752210B2
\end{enumerate}
\item Header Fingerprint
\begin{enumerate}
\item eine Methodik zur Identifikation eines Benutzers anhand der von ihm Verwendeten HTTP Header
\item Aggregation über allen Http-Header oder einem ausgewählten Set an Headerfeldern 
\item erzeugt Fingerprint wird gehasht und gespeichert
\item bei übereinstimmenden Fingerprints wird angenommen das diese vom gleichen Benutzer erzeugt wurden 
\end{enumerate}
\end{enumerate}
\newpage
\section{Set A / Set B}

Die angeführten DbSets FileEntryItemsA und FileEntryItemsB verfügen jeweils über Daten welche zu visualisieren sind. Dabei wird das DbSet FileEntryItemsA weiterhin als die ungeschützte Datenmenge beschrieben, da diese Datenbank nur mit Daten befüllt werden soll, bei welchen keine datenschutzfreundlichen Methoden zum anonymisieren verwendet wurden. Das DbSet FileEntryItemsB wird weiterhin als geschützte Datenmenge beschrieben, da ausschließlich Daten , welche mit Methoden zum anonymisieren hochgeladen wurden, verwendet werden sollen. Dabei sollte die geschützte und ungeschützte Datenmenge in den Zugrunde liegenden Datenmenge identisch sein und lediglich die Verwendung von Methoden zum anonymisieren die Datensätze unterscheiden, sodass die beiden Datenmenge miteinander in Hinblick auf den Effekt der Verwendung von Methoden zum anonymisieren untersucht werden können. 
So wird im jedem beschriebenen Szenario zur Benutzung des Dokumentenspeichers angenommen das ein Benutzer eine Datei einmal ohne die Verwendung von Methoden zum anonymisieren in die ungeschützte Datenmenge via HTTP hochlädt und einmal mit der Verwendung von Methoden zum anonymisieren in die geschützte Datenmenge via HTTP hochlädt.

Das führt dazu das bei der Auswertung der Datei durch die Verwendung oder nicht Verwendung von Methoden zum anonymisieren, die erfassten Meta-Daten sich nur durch die jeweilige Art der Methoden zum anonymisieren unterscheiden und die anschließenden Visualisierung nur diesen Unterschied darstellt und keine anderen Faktoren. 


\chapter{Hauptteil}

\section{Implementation des Dokumentenspeichers}

Die Implementation des Dokumentenspeichers ist mit dem ASP.NET Core Framework von Microsoft umgesetzt worden. \\
\glqq ASP.NET Core ist ein plattformübergreifendes, leistungsstarkes Open-Source-Framework zum Erstellen moderner, cloudbasierter mit dem Internet verbundener Anwendungen.\grqq \\
Der Dokumentenspeicher ist mittels einer Model-View-Controller Architektur realisiert worden. Die Model-View-Controller Architektur definiert, Modelle als Klassen welche die zugrundeliegende Problemstruktur wiedergeben. Sie modellieren die Objekte welche keine Informationen über ihre Verwendung besitzen. 
Views sind die Klassen welche die Darstellung der Modelle implementieren und den Output einer Systems darstellen. Controller sind die Kontroll-Klassen welche Views steuern und Input in das System verarbeiten. 

Das ausschlaggebende Modell im Dokumentenspeicher ist die FileEntryItem Klasse. Die Klasse definiert alle Porperties, welche die Meta-Data wieder spiegeln, welche vom Dokumentenspeicherdienst gesammelt werden. Mit Hilfe des Entity Framework Core von Microsoft werden aus dieser Modell-Klasse ein Datenbankschema erzeugt. Das Datenbankschema ist somit an die Modell-Klassen gekoppelt und führt dazu das Änderungen an den Modell-Klassen auch direkt Änderungen des Datenbankschemas erfordern, welche vom Entity Framework Core einfach erzeugt werden können. Das erzeugte Datenbankschema für FileEntryItem ist.

\lstinputlisting[language=csh, firstline=41, lastline=55]{sourceCode/FileEntryItem.cs}


Die einzelnen Properties werden für bestimme Informationen verwendet.

\begin{enumerate}
\item ID: Datenbank Index
\item Set: Das Set bezeichnet die Gruppe welcher die Datei zugeordnet wurde
\item Filename: Der Dateiname
\item Filepath: Der Pfad zur gespeicherten temporären Datei
\item Size: Die Dateigröße in Byte
\item IPAddress: Die IP-Adresse von der die Datei hochgeladen wurde
\item Headers: Ein String bestehend aus den Headern der Datei
\item HeaderFingerprint: Ein zusammenschluss aus ausgewähten Headern um eine möglichst eindeutige Signatur zu erzeugen
\item DateTime: Als Zeitstempel für das Hochladen der Datei
\item Country: Land aus welches die Datei hochgeladen wurde
\item RegionName: Region (Bundesland) aus welches die Datei hochgeladen wurde
\item City: Stadt aus welches die Datei hochgeladen wurde
\item Lat: Breitengrad welcher mit den bekannten IP-Adresse assoziiert wird
\item Isp: Internetanbierter des Benutzers der die Datei hochgeladen hat
\item Lon: Längengrad welcher mit den bekannten IP-Adresse assoziiert wird
\item Isp: Der Internetanbieter welcher der IP zugeordnet ist
\end{enumerate}

Für eine hoch geladene Datei werden diese 16 Informationen gespeichert und verwaltet.

Der UploadController, welche die API's implementiert besitzt eine Reihe von Methoden welche die API's die einem Benutzer zur Verfügung stehen implementieren. 

Für das Set A, die ungeschützte Datenmenge sowie für das Set B, die ungeschützte Datenmenge gibt es API Punkt welcher das Hochladen in die entsprechende Datenmenge ermöglicht. 

\lstinputlisting[language=c, firstline=40, lastline=56]{sourceCode/UploadController.cs}

In Line zwei bis Line acht wird eine API Punkt implementiert. 
\lstinputlisting[language=c, firstline=41, lastline=41]{sourceCode/UploadController.cs}
Ist das Keyword um eine Methode als einen API Punkt zu bereit zu stellen. Das HTTPPost Keyword definiert dabei einen Post API Punkt welcher Daten, im zuge eines Request entgegen nimmt und diese in der Regal verarbeitet. 

\lstinputlisting[language=c, firstline=43, lastline=47]{sourceCode/UploadController.cs}
Die Methode definiert als Rückgabewert ein RedirectToPageResult, welcher den Benutzer der diese API-benutzt als Antwort wieder zurück auf eine vordefinierte Page leitet. 
Da die Methode mit den HttpPost-Attribut getagt ist, ist im Methoden-Rumpf ein Request-Object verfügbar welches den HTTP-Request welcher gegen den API-Punkt gestellt wurde darstellt. Das Request-Object hält alle Informationen wie die Header, die hochgeladene Datei und die IP-Adresse des Benutzers und dient dazu die Meta-Daten des Uploads zu erfassen. Das Request-Object wird zusammen mit einen String Identifier für das Set, welches dem API-Punkt zugeordert wird, an eine Methode "ProcessPost" übergeben, welche den Request verarbeitet, indem die Meta-Daten gesammelt, die Datei, welche hochgeladen wurde, abspeichert und die Meta-Daten sowie den Pfad zu der hochgeladenen Datei in einer Datenbank geschrieben wird.


\section{Darstellung: IP Tree Map und IP Google Map}

Die Darstellung der gesammelten Daten über IP-Adressen Gruppierte Mengen.

Erzeugen des Gruppierungen aus der gegebenen Datenmenge. Nutzung des d3.js zur Darstellung der Tree Map. Dabei wird jeder IP-Gruppierung eine andere Farbe zugeordnet. Die Farbliche Visuelle Darstellung macht zusammengehörige Dateien nach IP-Adresse direkt sichtbar. Mit Hilfe der IP-Adressen und eines Geolookup kann ein ungefährer Standpunkt (Lat/Lon) der IP-Adresse gewonnen werden. Anhand dieses Standpunkts kann auf der Google Map der Standpunkt von wo eine Datei hochgeladen wurde aufgezeigt werden. 

Bei Verwendung von Methoden zur Anonymisieren der IP-Adresse wie z.B. das verwenden eines Proxys oder der Verwendung des TOR-Netzwerks, werden die IP-Adressen-Gruppierungen verzerrt, durch verzerrte Gruppen können Dateien eines Benutzer nicht mehr zu 100\% auf diesem Benutzer gemappt werden.

\begin{enumerate}
\item Proxy -> IP-Adresse wird maskiert
\begin{enumerate}
\item Falls der Proxy wird nur durch einen Benutzer benutzt -> keine Gruppenverzerrung 
\item Proxy wird von mehreren Benutzern benutzt -> Gruppenverzerrung 
\item Benutzer wechselt Proxy mehrfach -> Gruppierungen werden in der Gesamtheit verzerrt -> pro Benutzer mehre Gruppierungen 
\end{enumerate}
\item IP-Gruppierung über die Endknoten des Tor-Netzwerks 
\begin{enumerate}
\item Benutzer die den gleichen Endknoten benutzen werden gruppiert -> Gruppenverzerrung 
\item Durch automatischen wechsle der Endknoten -> Pro Benutzer zwangsläufig mehrere Gruppen -> Gruppenverzerrung 
\end{enumerate}
\end{enumerate}

\section{Darstellung: Headerfingerprinting}

Der Headerfingerprint welcher beim hochladen der Datei erzeugt wird, wird nun verwendet um die Dateien jeweils  

\section{Darstelung: Time Line}

\chapter{Schluss}

\section{Zusammenfassung der Ergebnisse}
\section{kritische Bewertung des Ergebnisse}
\section{neue Problemstellungen, Möglichkeiten zur Weiterführung der Arbeit}

\end{document}
